
server_private_key = '-----BEGIN RSA PRIVATE KEY-----\nMIIEowIBAAKCAQEAnJdl0MKhHQt8T9h1hefOl+DdBBP1kudIIq+aH7HpBV6aBoIq\nv0MgsNvIzEGtYF52anvAL7A8bWHulcKibP26yx5Jop0liBCZPvl53g4JqSJvhRsc\nVMW0FojpifhJTuiytPbJOACy/Um2DJZVJbnmm+40+QUcW61QLfRAKsNthmKjyeX9\nqAPJhImwie2GHNRDByMCWXDlnb/VS6XTgsZGw+2dqOAX7TRIDGAhumZ6RgJY298f\nxj5XUdQ4vXp9tPc7D1MhIhVR/s/AY/uIVpPgYfbzAZ9jgpMEsLckNcr3n6OstOFy\nMGtPWrRiPzL/SCjl3QkveGuWHAbabu+H9qX7KQIDAQABAoIBAHTlBAl6MUF4YH1O\nbjTe3bc9EmBH8guPAad7BQfiDLyIaVywcO7EUrQT7eqkoKOPAMDuzoILAqD4+Vzs\npcnNA1M7seZlfy36jhuXqqTcP9P1s+BeY6DY0V39KLFpGniAd19l1sIqq3MvQmpV\nEw0NoJwIj5zRduDtGSyk5/3EU498CgKF/06WpkSjWzx2WHA7bqBc/BqV17ZZ5q0Z\n9aZ7zUChYMZRSx+t0R+gzt0gNXvHKt1/UNGJMK1D0AbMfOM39TRiU9cCA6ovI8pm\n/P4DYAVr+yppgf/HbQqdN2C2qQmY2v16zbCOHNxOfv/RNRLyZe4pWksfsIsNiI/p\nn76F+N0CgYEAwVhaBZwiyTsVzBck6Zmj/naaKvcj2fw0nym6VHU519piUu3MfvZQ\nsFGGaiL926UxjoseFC7BeHqV+ou7KF7EoiV3LpyJ+kUkpsW+Rial2dlDLV8wbZHH\naWeRbERS+Whpt3V5qj3Ba19sehtCQWM5j3ENuiO7aWfKZQe7Znh27RcCgYEAz1YB\nx3POWOVrwD0r5GQmFfEzUhfltVEA/+qV/A9jW5tGbrpquEmeWBD94hIpmVEqQX9Z\ntpejtOCWETigL0Uv2RHsWyCHDbZ2M+TbHJnDxBW39di+11U9ggr8kYptCtHqmdCS\niAtM3yZKuxnNtZbS4KQXVflR41vEK8giKIOyAb8CgYEAqxbMqlQs8BbpxezhDBmZ\n5c37xHNndTjZM9LQAHavVdP419t37w11/2BU6kzGiPvYK4PtfPyW1U7cspW9aw7Z\nP4aZvVRmQGG4+h7Xren7Lxgzes3V489xP1OXes/HAM6lZeN9Yuk85A/PxQmkCoqM\nX+Mxu3ptF+vxTI+YBCgrTMcCgYA6bE7WCADWNdd19QbANaQxvKSsdkVpISk5871N\nqHxj3M4s92SJB12SDT+tC1cjd6aDjEIYXIRpvHss4RrqFwHTleRXDURhDdAi8VL4\nrS9nuoL6yJeGD+PkF/pxfGMbkGkd7JLNuPlxS9X1AOFhUN2dJT/aHwX/HeWaPKu7\nZNis+wKBgE5hN04NNSKAia2uJZvEp7ra0/H/6q61egKQ7ru4U/SaqSUy3yC7q6O3\n+7Sf0QQ3+w1cet3ol7zPqzvu0DG/HJYbpu5RThbXS4ePOqLJbfspvShqGCs2F6EG\nQyfAkiOquwyVHQ7ommLC2bQQJORIMHRSCQ+oHIBXKeDbrQvfcXPc\n-----END RSA PRIVATE KEY-----'
#server_public_key = '-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAnJdl0MKhHQt8T9h1hefO\nl+DdBBP1kudIIq+aH7HpBV6aBoIqv0MgsNvIzEGtYF52anvAL7A8bWHulcKibP26\nyx5Jop0liBCZPvl53g4JqSJvhRscVMW0FojpifhJTuiytPbJOACy/Um2DJZVJbnm\nm+40+QUcW61QLfRAKsNthmKjyeX9qAPJhImwie2GHNRDByMCWXDlnb/VS6XTgsZG\nw+2dqOAX7TRIDGAhumZ6RgJY298fxj5XUdQ4vXp9tPc7D1MhIhVR/s/AY/uIVpPg\nYfbzAZ9jgpMEsLckNcr3n6OstOFyMGtPWrRiPzL/SCjl3QkveGuWHAbabu+H9qX7\nKQIDAQAB\n-----END PUBLIC KEY-----'
client_public_key = '-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAkSq3EDTiGCnHM8nnwagJ\nsmqnqtgzsja8wKX6P2gr2NcfUtnvDW5jelmfnTuRLwCYcCQ6gpjo5M8KMeLdcbl6\nzB+zadTH5FVAj7DJHiHszx8lBGLLVOjWtR9OvucF13PCZ18SqCvld1WgxStSQWHt\nPsoGAbFdMg8UVRjnQW8MM1tNnI8ZsyFfzXHQTZr4Jn77rw8CZmMgHT5Bd5quE6An\n+mw1HFo2Tkao9ED2zIdU9JDNKvKErQrnDOHyrdWLcYZivrPhTYxqFrbkDRhKF93Y\n20xfLq3vgwWv19saBoNTkMrvBETTYCM0bw3Zm6z0PxcKFLgVMJHtuoFmnmgLxQne\ndwIDAQAB\n-----END PUBLIC KEY-----'

import socket
import sys
import cPickle as pickle
import time
import random
import openServicePort
import closeIndividualPort


from libs.crypto import encrypt_RSA, decrypt_RSA, sign_data, verify_sign


SERVER = 'localhost'
KNOCK_PORT = 8888

typeOfRequest = ''
user = ''
IPAddrOfClient = ''
otp = ''
nonce = ''
freshNonce = ''

# create dgram udp socket
try:
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
except socket.error:
    print 'Failed to create socket'
    sys.exit()

# Bind socket to local host and port
try:
    s.bind((SERVER, KNOCK_PORT))
except socket.error , msg:
    print 'Bind failed. Error Code : ' + str(msg[0]) + ' Message ' + msg[1]
    sys.exit()

print 'Socket bind complete'


def checkAuthencityOfMsg(data_signed, data_enc):
    if (verify_sign(client_public_key, data_signed, data_enc)):
        print "User is authentic"
        #print pickle.loads(data_plain)
        return True
    else:
        print "User is not authentic"
        return False


def checkIPMatches(addr, data):
    if (addr[0] == data[2]):
        print "IP matches"
        return True
    else:
        print "IP do not match: " + addr[0] + " " + data[2]
        return False


def checkNonceFreshness(nonceA):
    if ( int(time.time()) - nonceA <= 30 ):
        print 'nonce is still fresh'
        return True
    else:
        print 'stale nonce'
        return False


def checkServerNonce(nonceServer, rec_nonceServer):
    if (rec_nonceServer == nonceServer):
        print 'Server nonce is fresh'
        return True
    else:
        print 'Server nonce is stale'
        return False

#server_private_key = ''
#get private key from pi db
while(1) :
    typeOfRequest = ''
    user = ''
    IPAddrOfClient = ''
    otp = ''
    nonce = ''
    serverNonce = ''

    try :
        #first comms
        d = s.recvfrom(1024)
        data = d[0]
        addr = d[1]

        if not data:
            break

        data = pickle.loads(data)
        data_enc = data[0]
        data_signed = data[1]
        data_plain = decrypt_RSA(server_private_key, data_enc)
        data_plain = pickle.loads(data_plain)
        #data_plain[1] is the user. Query for this user and set the following:
        #client_public_key = query from db

        isUserAuthentic = checkAuthencityOfMsg(data_signed, data_enc)
        isIPReal = checkIPMatches(addr, data_plain)
        nonceClient = data_plain[5]
        isNonceFresh = checkNonceFreshness(nonceClient)
        #check otp
        #if else to ensure all true. then continue


        #second comms
        nonceServer = random.randint(100000000, 999999999)
        reply = [nonceClient, nonceServer]
        reply = pickle.dumps(reply)
        reply_enc = encrypt_RSA(client_public_key, reply)
        reply_signed = sign_data(server_private_key, reply_enc)
        reply_payload = [reply_enc, reply_signed]
        reply_payload = pickle.dumps(reply_payload)
        s.sendto(reply_payload , addr)

        #third comms
        d = s.recvfrom(1024)
        data = d[0]
        addr = d[1]

        rec_data = pickle.loads(data)
        rec_data_enc = rec_data[0]
        rec_data_signed = rec_data[1]
        rec_data_plain = decrypt_RSA(server_private_key, rec_data_enc)
        rec_data_plain = pickle.loads(rec_data_plain)
        rec_nonceServer = rec_data_plain
        isUserAuthentic = checkAuthencityOfMsg(rec_data_signed, rec_data_enc)
        isServerNonceFresh = checkServerNonce(nonceServer, rec_nonceServer)

        print "Operation: " + data_plain[1]
        #Call teye script to open or close port.
        #data_plain[0] is the type of operation, open or close
        #data_plain[2] is the ip address, obtained from clientComms scriptr, verified with header
        #data_plain[3] is the port, to open or closed
        if data_plain[0] == "open":
            openServicePort.open_service_port(data_plain[2], int(data_plain[3]))
        else:
            closeIndividualPort.close_service_port(data_plain[2], int(data_plain[3]))

    except socket.error, msg:
        print 'Error Code : ' + str(msg[0]) + ' Message ' + msg[1]
        sys.exit()
